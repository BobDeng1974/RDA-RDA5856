/* 
 * Copyright (c) 2006-2016 RDA Microelectronics, Inc.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/                                                 
//------------------------------------------------------------------------
// File name      : i2c_master                                            
// Author         : liqiu                                                 
// Date of created: 2016-08-29 14:59:50                                                  
// Last modified  : 2016-08-29 14:59:50                                                  
//------------------------------------------------------------------------
// Reversion History:                                                     
// 2016-08-29 14:59:50 --  Create by liqiu                                               
//------------------------------------------------------------------------
#ifndef __I2C_MASTER_H__
#define __I2C_MASTER_H__
//Auto-gen by reg_gen
#include "base_address.h"
#include "type_def.h"
#define  NORMAL_CHEAD


typedef volatile struct
{
    REG32                          CTRL;                         //0x00000000
    REG32                          STATUS;                       //0x00000004
    REG32                          TXRX_BUFFER;                  //0x00000008
    REG32                          CMD;                          //0x0000000C
    REG32                          IRQ_CLR;                      //0x00000010
} HWP_I2C_MASTER_T;

#define hwp_i2cMaster               ((HWP_I2C_MASTER_T*) KSEG1(REG_I2C_MASTER_BASE))
#define hwp_i2cMaster2              ((HWP_I2C_MASTER_T*) KSEG1(REG_I2C_MASTER_BASE))
#define hwp_i2cMaster3              ((HWP_I2C_MASTER_T*) KSEG1(REG_I2C_MASTER_BASE))

#ifndef NORMAL_CHEAD
//ctrl
typedef union
{
    U32 v;
    struct
    {
        U32 en                             :1 ; /*0 :0 , I2C master enable, high active.*/
        U32 ctrl_reserved_1                :7 ; /*7 :1 , No description.               */
        U32 irq_mask                       :1 ; /*8 :8 , I2C master interrupt enable, high active.*/
        U32 ctrl_reserved_0                :7 ; /*15:9 , No description.               */
        U32 clock_prescale                 :16; /*31:16, This register is used to prescale the SCL clock line. Due to the structure of I2C interface, this module uses a 5*SCL clock frequency. Clock_Prescale must be programmed to this 5*SCL clock frequency (minus 1). Change the value of Clock_Prescale only when bit EN is cleared. Example:PCLK_MOD is 52 MHz, desired SCL is 100 KHz. Prescale = 52MHz / (5 * 100KHz) -1 = 103.*/
    } b;
} T_I2C_MASTER_ctrl;

//status
typedef union
{
    U32 v;
    struct
    {
        U32 irq_cause                      :1 ; /*0 :0 , IRQ Cause bit. This bit is set when one byte transfer has been completed or arbitration is lost, this bit is generated by bit IRQ_Status AND bit IRQ_MASK.*/
        U32 status_reserved_5              :3 ; /*3 :1 , No description.               */
        U32 irq_status                     :1 ; /*4 :4 , IRQ status bit.               */
        U32 status_reserved_4              :3 ; /*7 :5 , No description.               */
        U32 tip                            :1 ; /*8 :8 , TIP, Transfer in progress. 0 : NO_TRANS when transfer complete.1 : TRANS_DATA when transferring data.*/
        U32 status_reserved_3              :3 ; /*11:9 , No description.               */
        U32 al                             :1 ; /*12:12, AL,Arbitration lost. This bit is set when the I2C master lost arbitration.*/
        U32 status_reserved_2              :3 ; /*15:13, No description.               */
        U32 busy                           :1 ; /*16:16, Busy,I2C bus busy. 0 :  AFTER_STOP after STOP signal detected.1 :  AFTER_START after START signal detected. */
        U32 status_reserved_1              :3 ; /*19:17, No description.               */
        U32 rxack                          :1 ; /*20:20, RxACK, Received acknowledge from slave. 0:  ACK  received. 1:  NACK  received.*/
        U32 status_reserved_0              :11; /*31:21, No description.               */
    } b;
} T_I2C_MASTER_status;

//txrx_buffer
typedef union
{
    U32 v;
    struct
    {
        U32 tx_data_0                      :1 ; /*0 :0 , use as write reg:in case of a data transfer this bit represents the data's LSB. In case of a slave address transfer this bit represents the RW bit. 0 : WRITE writing to slave.1 : READ reading from slave.Use as read reg:last received data[0] via I2C*/
        U32 tx_data_7_1                    :7 ; /*7 :1 , use as write reg:Byte to transmit via I2C.Use as read reg: last received data[7:1] via I2C*/
        U32 txrx_buffer_reserved_0         :24; /*31:8 , No description.               */
    } b;
} T_I2C_MASTER_txrx_buffer;

//cmd
typedef union
{
    U32 v;
    struct
    {
        U32 ack                            :1 ; /*0 :0 , ACK,when master works as a receiver,sent ACK(ACK='0') or NACK(ACK='1').0 : ACK1 : NACK*/
        U32 cmd_reserved_4                 :3 ; /*3 :1 , No description.               */
        U32 rd                             :1 ; /*4 :4 , RD,read from slave, this bit is auto cleared.*/
        U32 cmd_reserved_3                 :3 ; /*7 :5 , No description.               */
        U32 sto                            :1 ; /*8 :8 , STO,generate stop condition, this bit is auto cleared.*/
        U32 cmd_reserved_2                 :3 ; /*11:9 , No description.               */
        U32 wr                             :1 ; /*12:12, WR,write to slave, this bit is auto cleared.*/
        U32 cmd_reserved_1                 :3 ; /*15:13, No description.               */
        U32 sta                            :1 ; /*16:16, STA,generate (repeated) start condition, this bit is auto cleared.*/
        U32 cmd_reserved_0                 :15; /*31:17, No description.               */
    } b;
} T_I2C_MASTER_cmd;

//irq_clr
typedef union
{
    U32 v;
    struct
    {
        U32 irq_clr                        :1 ; /*0 :0 , When write '1', clears a pending I2C interrupt.*/
        U32 irq_clr_reserved_0             :31; /*31:1 , No description.               */
    } b;
} T_I2C_MASTER_irq_clr;

typedef struct
{
    volatile               T_I2C_MASTER_ctrl                           ctrl; /*0x0  , RW   , 0xFFFF0000, No description.               */
    volatile             T_I2C_MASTER_status                         status; /*0x4  , RO   , 0x00000000, No description.               */
    volatile        T_I2C_MASTER_txrx_buffer                    txrx_buffer; /*0x8  , RW   , 0x00000000, No description.               */
    volatile                T_I2C_MASTER_cmd                            cmd; /*0xc  , WO   , 0x00000000, No description.               */
    volatile            T_I2C_MASTER_irq_clr                        irq_clr; /*0x10 , RW   , 0x00000000, No description.               */
} T_HWP_I2C_MASTER_T;
#else
typedef struct
{
    volatile                             U32                           ctrl; /*0x0  , RW   , 0xFFFF0000, No description.               */
    volatile                             U32                         status; /*0x4  , RO   , 0x00000000, No description.               */
    volatile                             U32                    txrx_buffer; /*0x8  , RW   , 0x00000000, No description.               */
    volatile                             U32                            cmd; /*0xc  , WO   , 0x00000000, No description.               */
    volatile                             U32                        irq_clr; /*0x10 , RW   , 0x00000000, No description.               */
} T_HWP_I2C_MASTER_T;

//ctrl
#define I2C_MASTER_EN                  (1<<0)              

#define I2C_MASTER_IRQ_MASK            (1<<8)              

#define I2C_MASTER_CLOCK_PRESCALE(n)   (((n)&0xFFFF)<<16)  
#define I2C_MASTER_CLOCK_PRESCALE_MASK (0xFFFF<<16)        
#define I2C_MASTER_CLOCK_PRESCALE_SHIFT (16)                


//status
#define I2C_MASTER_IRQ_CAUSE           (1<<0)              

#define I2C_MASTER_IRQ_STATUS          (1<<4)              

#define I2C_MASTER_TIP                 (1<<8)              
#define I2C_MASTER_TIP_NO_TRANS        (1<<8)              
#define I2C_MASTER_TIP_TRANS_DATA      (1<<8)              

#define I2C_MASTER_AL                  (1<<12)             

#define I2C_MASTER_BUSY                (1<<16)             
#define I2C_MASTER_BUSY_AFTER_STOP     (1<<16)             
#define I2C_MASTER_BUSY_AFTER_START    (1<<16)             

#define I2C_MASTER_RXACK               (1<<20)             
#define I2C_MASTER_RXACK_ACK           (1<<20)             
#define I2C_MASTER_RXACK_NACK          (1<<20)             


//txrx_buffer
#define I2C_MASTER_TX_DATA_0           (1<<0)              
#define I2C_MASTER_TX_DATA_0_WRITE     (1<<0)              
#define I2C_MASTER_TX_DATA_0_READ      (1<<0)              

#define I2C_MASTER_TX_DATA_7_1(n)      (((n)&0x7F)<<1)     
#define I2C_MASTER_TX_DATA_7_1_MASK    (0x7F<<1)           
#define I2C_MASTER_TX_DATA_7_1_SHIFT   (1)                 


//cmd
#define I2C_MASTER_ACK                 (1<<0)              
#define I2C_MASTER_ACK_ACK             (1<<0)              
#define I2C_MASTER_ACK_NACK            (1<<0)              

#define I2C_MASTER_RD                  (1<<4)              

#define I2C_MASTER_STO                 (1<<8)              

#define I2C_MASTER_WR                  (1<<12)             

#define I2C_MASTER_STA                 (1<<16)             


//irq_clr
#define I2C_MASTER_IRQ_CLR             (1<<0)              


#endif

#endif


