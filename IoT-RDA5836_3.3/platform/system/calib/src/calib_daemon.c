/* 
 * Copyright (c) 2006-2016 RDA Microelectronics, Inc.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
/// @file calib_daemon.c 
/// This file implements the calibration daemon functionality, for both lab
/// and production modes.
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include "cs_types.h"
#include "chip_id.h"
#include "string.h"

#include "calib_m.h"
#include "calibp_defaults.h"
#include "calibp_debug.h"
#include "calibp_calibration.h"
#include "tgt_calib_cfg.h"

#include "pal_gsm.h"
#include "hal_mem_map.h"
#include "hal_dma.h"
#include "hal_host.h"
#include "hal_rda_audio.h"

#ifdef CHIP_HAS_AP
#include "hal_ap_comm.h"
#include "syscmds_m.h"
#endif

#include "sxr_mem.h"
#include "sxr_tls.h"

#include "memd_m.h"

#include "rfd_pa.h"
#include "rfd_sw.h"
#include "rfd_xcv.h"
extern UINT8 g_Calib_OnSite;
extern VOID calib_ConvertStructV2p2(CALIB_BB_T *pCalibBb);
extern VOID calib_ConvertStructV2p4(CALIB_BB_T *pCalibBb);
extern VOID calib_ConvertStructV2p5(CALIB_BB_T *pCalibBb);

#define STR(x) #x

// Check the chip ID generated by CAT tool
#if (DEFAULT_CALIB_CHIP_ID != CHIP_ASIC_ID)
#define CHIP_ID_ERR(catChipId, chipId) \
    STR(DEFAULT_CALIB_CHIP_ID [catChipId]  \
        in calibp_audio_defaults.h is incorrect. Should be  \
        [chipId])
#include CHIP_ID_ERR(DEFAULT_CALIB_CHIP_ID, CHIP_ASIC_ID)
#endif

#if (CHIP_ASIC_ID == CHIP_ASIC_ID_GALLITE)
#if (DEFAULT_CALIB_CHIP_DIE == 8805)
#if !defined(GALLITE_IS_8805)
#error "DEFAULT_CALIB_CHIP_DIE [8805] in calibp_audio_defaults.h is incorrect."
#endif
#elif (DEFAULT_CALIB_CHIP_DIE == 8806)
#if !defined(GALLITE_IS_8806)
#error "DEFAULT_CALIB_CHIP_DIE [8806] in calibp_audio_defaults.h is incorrect."
#endif
#else // not 8805 or 8806
#error "DEFAULT_CALIB_CHIP_DIE in calibp_audio_defaults.h is invalid."
#endif
#endif // CHIP_ASIC_ID_GALLITE

// Check the calib version generated by CAT tool
#if (DEFAULT_CALIB_VERSION != CALIB_VERSION_NUMBER)
#define VERSION_ERR(catCalibVer, calibVer) \
    STR(DEFAULT_CALIB_VERSION [catCalibVer] \
        in calibp_audio_defaults.h is incorrect. Should be \
        [calibVer])
#include VERSION_ERR(DEFAULT_CALIB_VERSION, CALIB_VERSION_NUMBER)
#endif


// =============================================================================
// Definitions
// =============================================================================

#define CALIB_CHECK_RF_NAME 1

#define CALIB_CHECK_MINOR_VERSION 1

#define CALIB_UNCACHED_BSS __attribute__((section(".ucbss")))


// =============================================================================
// _calib_start
// -----------------------------------------------------------------------------
/// Start address of the calibration sector, in the flash.
/// Come from the linker.
// =============================================================================
extern CALIB_BUFFER_T _calib_start;


// =============================================================================
// _calib_size
// -----------------------------------------------------------------------------
/// Size of the calibration data
/// Come from the linker.
// =============================================================================
extern UINT32 _calib_size;


//  -------------------------------------------------- 
//  ----- Address of the calibration sector in flash. 

/// Calibrated parameters buffer (used when the platform has been calibrated).
/// This buffer is in flash and can be re-burnt ONLY using CalibTool.
/// The symbol "_calib_start" is in a dedicated sector of the flash and is
/// not erased while programming the flash. It is defined by LD script. 
CONST CALIB_BUFFER_T* CONST g_calibCalibSector = &_calib_start;


//  -------------------------------------------------- 
//  ----- Default values for baseband calibration. 

///  Default calib values. Used when the platform hasn't been calibrated (the
///  status flag of "g_calibCalibSector" is checked during the calib init). 
CONST CALIB_OP_INFO_T g_calibOpInfoDefault =
{
    0 /* The time of epoch. */, CALIB_METH_DEFAULT
};


#ifdef CALIB_AUDIO_OTHER
/// Baseband default calibration
CONST CALIB_BB_T g_calibBbDefault =
{
    DEFAULT_CALIB_PAL_TIMES,
    {
        // ITF 0 - Receiver
        {
            DEFAULT_CALIB_AUDIO_VOC_HS_EC,
#if (AUDIO_CALIB_VER == 1)
            DEFAULT_CALIB_AUDIO_VOC_RESERVE,
#else
            DEFAULT_CALIB_AUDIO_VOC_HS_FILTERS,
#endif
            DEFAULT_CALIB_AUDIO_GAINS_HS,
            DEFAULT_CALIB_AUDIO_HS_PARAMS,
        },

        // ITF 1 - Earpiece
        {
            DEFAULT_CALIB_AUDIO_VOC_EP_EC,
#if (AUDIO_CALIB_VER == 1)
            DEFAULT_CALIB_AUDIO_VOC_RESERVE,
#else
            DEFAULT_CALIB_AUDIO_VOC_EP_FILTERS,
#endif
            DEFAULT_CALIB_AUDIO_GAINS_EP,
            DEFAULT_CALIB_AUDIO_EP_PARAMS,
        },

        // ITF 2 - Loudspeaker
        {
            DEFAULT_CALIB_AUDIO_VOC_LS_EC,
#if (AUDIO_CALIB_VER == 1)
            DEFAULT_CALIB_AUDIO_VOC_RESERVE,
#else
            DEFAULT_CALIB_AUDIO_VOC_LS_FILTERS,
#endif
            DEFAULT_CALIB_AUDIO_GAINS_LS,
            DEFAULT_CALIB_AUDIO_LS_PARAMS,
        },

        // ITF 3 - Bluetooth Audio
        {
            DEFAULT_CALIB_AUDIO_VOC_BT_EC,
#if (AUDIO_CALIB_VER == 1)
            DEFAULT_CALIB_AUDIO_VOC_RESERVE,
#else
            DEFAULT_CALIB_AUDIO_VOC_BT_FILTERS,
#endif
            DEFAULT_CALIB_AUDIO_GAINS_BT,
            DEFAULT_CALIB_AUDIO_BT_PARAMS,
        },

        // ITF 4 - FM Radio
        {
            DEFAULT_CALIB_AUDIO_VOC_FM_EC,
#if (AUDIO_CALIB_VER == 1)
            DEFAULT_CALIB_AUDIO_VOC_RESERVE,
#else
            DEFAULT_CALIB_AUDIO_VOC_FM_FILTERS,
#endif
            DEFAULT_CALIB_AUDIO_GAINS_FM,
            DEFAULT_CALIB_AUDIO_FM_PARAMS,
        },

        // ITF 5 - Not used yet
        {
            DEFAULT_CALIB_AUDIO_VOC_TV_EC,
#if (AUDIO_CALIB_VER == 1)
            DEFAULT_CALIB_AUDIO_VOC_RESERVE,
#else
            DEFAULT_CALIB_AUDIO_VOC_TV_FILTERS,
#endif
            DEFAULT_CALIB_AUDIO_GAINS_TV,
            DEFAULT_CALIB_AUDIO_TV_PARAMS,
        },
    },

    DEFAULT_CALIB_GPADC,
};

#endif

/// IIR default calibration
CONST CALIB_AUDIO_IIR_PARAM_T g_calibIIRDefault =
{
    // ITF 0 - Receiver
    //DEFAULT_CALIB_AUDIO_IIR_PARAM_HS,

    // ITF 1 - Earpiece
    //DEFAULT_CALIB_AUDIO_IIR_PARAM_EP,

    // ITF 2 - Loudspeaker
    //DEFAULT_CALIB_AUDIO_IIR_PARAM_LS,

    // ITF 3 - Bluetooth Audio
    //DEFAULT_CALIB_AUDIO_IIR_PARAM_BT,

    // ITF 4 - FM Radio
    //DEFAULT_CALIB_AUDIO_IIR_PARAM_FM,

    // ITF 5 - TV
    //DEFAULT_CALIB_AUDIO_IIR_PARAM_TV,
};

#if (AUDIO_CALIB_VER == 1)
CONST CALIB_AUD_VOC_T g_calibAudioVoCDefault = 
{
    {
    // ITF 0 - Receiver
    //DEFAULT_CALIB_AUDIO_VOC_PARAM_HS,
    
    // ITF 1 - Earpiece
    //DEFAULT_CALIB_AUDIO_VOC_PARAM_EP,

    // ITF 2 - Loudspeaker
    //DEFAULT_CALIB_AUDIO_VOC_PARAM_LS,

    // ITF 3 - Bluetooth Audio
    //DEFAULT_CALIB_AUDIO_VOC_PARAM_BT,

    // ITF 4 - FM Radio
    //DEFAULT_CALIB_AUDIO_VOC_PARAM_FM,

    // ITF 5 - TV
    //DEFAULT_CALIB_AUDIO_VOC_PARAM_TV,
    },
};

CONST CALIB_AUD_MUSIC_T g_calibAudioMusicDefault = 
{
    {
    // ITF 0 - Receiver
    //DEFAULT_CALIB_AUDIO_MUSIC_PARAM_HS,

    // ITF 1 - Earpiece
    //DEFAULT_CALIB_AUDIO_MUSIC_PARAM_EP,

    // ITF 2 - Loudspeaker
    //DEFAULT_CALIB_AUDIO_MUSIC_PARAM_LS,

    // ITF 3 - Bluetooth Audio
    //DEFAULT_CALIB_AUDIO_MUSIC_PARAM_BT,

    // ITF 4 - FM Radio
    //DEFAULT_CALIB_AUDIO_MUSIC_PARAM_FM,

    // ITF 5 - TV
    //DEFAULT_CALIB_AUDIO_MUSIC_PARAM_TV,
    },
};
#endif
// =============================================================================
// g_calibCalibration
// -----------------------------------------------------------------------------
///  Global calibration structure.
///
/// Global pointers used by garnet's code to get the calibrated parameters. By
/// default, it is initialized with default parameters during calibration
/// init. And pointers used by HST to get the version number of the 
/// calibration, and to find the calibration buffers. 
// =============================================================================
PROTECTED CALIB_CALIBRATION_T g_calibCalibration =
{
    CALIB_VERSION_NUMBER,
    CALIB_PARAM_INIT_ERROR,
    CALIB_CMD_NOT_ACCESSIBLE,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    (CALIB_BUFFER_T*) &_calib_start,
    NULL,
    NULL,
    NULL
    #if (AUDIO_CALIB_VER == 1)
    ,NULL
    ,NULL
    ,NULL    
    #endif
};



//  -------------------------------------------------- 
//  ----- Calibration process variables. 

///  We add two sets of calibration buffer in RAM to put data from HST,
///  when a calib is being done. 

CALIB_OP_INFO_T  g_calibUsedOpInfo;
CALIB_XCV_T      g_calibUsedXcv;
CALIB_PA_T       g_calibUsedPa;
CALIB_SW_T       g_calibUsedSw;
CALIB_BB_T       g_calibUsedBb;
CALIB_AUDIO_IIR_PARAM_T	g_calibUsedIIR;

#if (AUDIO_CALIB_VER == 1)
CALIB_AUD_VOC_T              g_calibUsed_audio_voc; //
CALIB_AUD_MUSIC_T            g_calibUsed_audio_music; //
#endif
VOLATILE CALIB_OP_INFO_T CALIB_UNCACHED_BSS g_calibHstOpInfo;
VOLATILE CALIB_XCV_T     CALIB_UNCACHED_BSS g_calibHstXcv;
VOLATILE CALIB_PA_T      CALIB_UNCACHED_BSS g_calibHstPa;
VOLATILE CALIB_SW_T      CALIB_UNCACHED_BSS g_calibHstSw;
VOLATILE CALIB_BB_T      CALIB_UNCACHED_BSS g_calibHstBb;
VOLATILE CALIB_AUDIO_IIR_PARAM_T CALIB_UNCACHED_BSS g_calibHstIIR;
#if (AUDIO_CALIB_VER == 1)
VOLATILE CALIB_AUD_VOC_T      CALIB_UNCACHED_BSS          g_calibHst_audio_voc; //
VOLATILE CALIB_AUD_MUSIC_T   CALIB_UNCACHED_BSS         g_calibHst_audio_music; //
#endif


#ifdef CHIP_HAS_AP
PRIVATE BOOL g_calibAutoCallMode = FALSE;
#endif


// =============================================================================
//  FUNCTIONS
// =============================================================================

INLINE VOID *calib_memcpy(VOLATILE VOID *dest, CONST VOLATILE VOID *src, UINT32 n)
{
    return memcpy((VOID *)dest, (CONST VOID *)src, n);
}



//=============================================================================
// calib_GetPointers
//-----------------------------------------------------------------------------
/// Access to the calibration parameters.
///
/// @return The global pointers used by the code to access the calibrated
/// parameters. When the target's flash does not contain a flash sector,
/// the calib parameters are initialized with default parameters during
/// the calibration init. Also returns the pointers used by the remote
/// calibration tools to get the version number of the calibration and to 
/// find the calibration buffers.
//=============================================================================
PUBLIC CALIB_CALIBRATION_T* calib_GetPointers(VOID)
{
    return (&g_calibCalibration);
}




//  -------------------------------------------------- 
//  ----- Calibration trace print. 

//  Display information about the current calibration through the trace. 
#define _PAL  _HAL

#define calib_Print(x)         CALIB_TRACE(_PAL | TSTDOUT, 0, "Calibration: "x)
#define calib_Print1(x, y)     CALIB_TRACE(_PAL | TSTDOUT, 0, "Calibration: "x, y)
#define calib_PrintVal(x)      CALIB_TRACE(_PAL | TSTDOUT, 0, \
                                "Calibration: " #x " = %d", x)
#define calib_PrintUVal(x)     CALIB_TRACE(_PAL | TSTDOUT, 0,\
                                "Calibration: " #x " = %u", x)
#define calib_PrintXVal(x)     CALIB_TRACE(_PAL | TSTDOUT, 0,\
                                "Calibration: " #x " = 0x%x", x)




//=============================================================================
// calib_DaemonTracePrint
//-----------------------------------------------------------------------------
/// Display in the trace the current calibration status, used for debug.
//=============================================================================
PUBLIC VOID calib_DaemonTracePrint(VOID)
{
    //  Display the version and the parameters origin. 
    if (g_calibCalibration.paramStatus == CALIB_PARAM_CALIBRATED)
    {
        calib_Print("Using calibrated parameters from flash sector.");
    }
    else if (g_calibCalibration.paramStatus == CALIB_PARAM_DEFAULT)
    {
        calib_Print("Using default calib, platform NOT calibrated.");
    }
    else if (g_calibCalibration.paramStatus == CALIB_PARAM_DEFAULT_RF_MIS)
    {
        calib_Print("Using default calib, "
                 "flash sector NOT compatible with RF chips.");
    }
    else if (g_calibCalibration.paramStatus == CALIB_PARAM_INIT_ERROR)
    {
        calib_Print("ERROR! Problem during the init of the calibration.");
    }
    else if (g_calibCalibration.paramStatus == CALIB_PARAM_RF_CALIBRATED)
    {
        calib_Print("Audio Using default calib, platform RF calibrated.");
    }
    else if (g_calibCalibration.paramStatus == CALIB_PARAM_AUDIO_CALIBRATED)
    {
        calib_Print("Audio has been calibrated, platform Rf NOT calibrated.");
    }
    else if (g_calibCalibration.paramStatus == CALIB_PARAM_AUDIO_CALIBRATED_RF_MIS)
    {
        calib_Print("Audio has been calibrated,"
                 "flash sector NOT compatible with RF chips.");
    }
    else
    {
        calib_Print("ERROR! Unknown calibration parameter used!");
    }

    calib_Print1("Calib code version = 0x%x", CALIB_VERSION_NUMBER);
    calib_Print1("Flash version tag = 0x%x", g_calibCalibSector->versionTag);
    calib_Print1("Flash sector address = 0x%x", g_calibCalibSector);
    calib_Print1("Calib method = 0x%x", g_calibCalibration.opInfo->method);

    //  Display the values of the calib parameters. 
    calib_Print("Using RF chips:");
    calib_PrintXVal(g_calibCalibration.xcv->palcust.name);
    calib_PrintXVal(g_calibCalibration.pa->palcust.name);
    calib_PrintXVal(g_calibCalibration.sw->palcust.name);

    //  Display the calibration mode used. 
    calib_Print("Code compiled to calibrate platforms.");
}



//  -------------------------------------------------- 
//  ----- Calibration mechanism and structures init. 

//  Get the default calibration parameters values and set the HST calib
//  * buffers with it. This is used to init the calibration buffers and when
//  * the reset calib command is called. 

//  After this, calib_UpdateBuffer() function must be called to copy the
//  * default parameters from HST buffers to used buffers. 

PRIVATE VOID calib_SetRfBufferToDefault(VOID)
{
    // Default calibration values from the RF drivers. 
    CONST CALIB_XCV_T *xcvDefaults = rfd_XcvCalibGetDefault();
    CONST CALIB_PA_T  *paDefaults =  rfd_PaCalibGetDefault();
    CONST CALIB_SW_T  *swDefaults =  rfd_SwCalibGetDefault();

    // Copy calib param from flash to HST RAM buffer to be able to
    // modify them from HST. 
    calib_memcpy(&g_calibHstOpInfo,
                 &g_calibOpInfoDefault,
                 sizeof(g_calibHstOpInfo));

    calib_memcpy(&g_calibHstXcv,
                 xcvDefaults,
                 sizeof(g_calibHstXcv));

    calib_memcpy(&g_calibHstPa,
                 paDefaults,
                 sizeof(g_calibHstPa));

    calib_memcpy(&g_calibHstSw,
                 swDefaults,
                 sizeof(g_calibHstSw));
#ifdef CALIB_AUDIO_OTHER
    calib_memcpy(&g_calibHstBb.times,
                 &g_calibBbDefault.times,
                 sizeof(g_calibHstBb.times));

    calib_memcpy(&g_calibHstBb.gpadc,
                 &g_calibBbDefault.gpadc,
                 sizeof(g_calibHstBb.gpadc));
#endif
}


PRIVATE VOID calib_SetAudioBufferToDefault(VOID)
{
#ifdef CALIB_AUDIO_OTHER
    calib_memcpy(&g_calibHstBb.audio,
                 &g_calibBbDefault.audio,
                 sizeof(g_calibHstBb.audio));
#endif

    calib_memcpy(&g_calibHstIIR,
                 &g_calibIIRDefault,
                 sizeof(g_calibHstIIR));

#if (AUDIO_CALIB_VER == 1)
    calib_memcpy(&g_calibHst_audio_voc,
                 &g_calibAudioVoCDefault,
                 sizeof(g_calibUsed_audio_voc));
    calib_memcpy(&g_calibHst_audio_music,
                 &g_calibAudioMusicDefault,
                 sizeof(g_calibUsed_audio_music));
#endif
}


/// ----- Updating the HST buffer from the used buffers (USE CALIB). 
/// Copy the calib parameters from the HST RAM buffer to the used RAM
/// buffer. This function is called when the calib parameters are modified
/// by HST. Note: it does not update VoC or the bandgap cal. 
PRIVATE VOID calib_UpdateRfBuffer(VOID)
{
    // Copy HST calib param to used calib data. 
    calib_memcpy(&g_calibUsedOpInfo,
                 &g_calibHstOpInfo,
                 sizeof(g_calibUsedOpInfo));

    calib_memcpy(&g_calibUsedXcv,
                 &g_calibHstXcv,
                 sizeof(g_calibUsedXcv));

    calib_memcpy(&g_calibUsedPa,
                 &g_calibHstPa,
                 sizeof(g_calibUsedPa));

    calib_memcpy(&g_calibUsedSw,
                 &g_calibHstSw,
                 sizeof(g_calibUsedSw));

    calib_memcpy(&g_calibUsedBb.times,
                 &g_calibHstBb.times,
                 sizeof(g_calibUsedBb.times));

    calib_memcpy(&g_calibUsedBb.gpadc,
                 &g_calibHstBb.gpadc,
                 sizeof(g_calibUsedBb.gpadc));
}


PRIVATE VOID calib_UpdateAudioBuffer(VOID)
{
    // Copy HST calib param to used calib data. 
    calib_memcpy(&g_calibUsedBb.audio,
                 &g_calibHstBb.audio,
                 sizeof(g_calibUsedBb.audio));
    calib_memcpy(&g_calibUsedIIR,
                 &g_calibHstIIR,
                 sizeof(g_calibUsedIIR));

#if (AUDIO_CALIB_VER == 1)
    calib_memcpy(&g_calibUsed_audio_voc,
                 &g_calibHst_audio_voc,
                 sizeof(g_calibUsed_audio_voc));
    calib_memcpy(&g_calibUsed_audio_music,
                 &g_calibHst_audio_music,
                 sizeof(g_calibUsed_audio_music));

#endif
}


PRIVATE VOID calib_UpdateBuffer(VOID)
{
    calib_UpdateRfBuffer();
    calib_UpdateAudioBuffer();
}


PUBLIC UINT8 calib_CheckRfCrc(VOID)
{
    UINT32 tag = g_calibCalibSector->versionTag;

    if (tag >= 0xCA1B0204)
    {
        HAL_DMA_FCS_CFG_T   fcsCtx;
        CALIB_RF_CRC_T      fcs;

        fcs                 = 0;
        fcsCtx.srcAddr      = (UINT8*)&g_calibCalibSector->versionTag;
        fcsCtx.transferSize = OFFSETOF(CALIB_BUFFER_T, bb) - OFFSETOF(CALIB_BUFFER_T, versionTag);
        fcsCtx.userHandler  = NULL;
        if (hal_DmaFcsStart(&fcsCtx) == HAL_ERR_NO)
        {
            hal_DmaReadFcs((UINT8*)&fcs);
        }
        else
        {
            sxr_ComputeFcs(fcsCtx.transferSize, fcsCtx.srcAddr, (UINT8*)&fcs);
        }
        if(fcs == g_calibCalibSector->rfCrc)
        {
            // rf calibration crc ok
            hal_HstSendEvent(SYS_EVENT,0xca1bc2c0);
            return 0;
        }
        else
        {
            // rf calibration crc fail
            hal_HstSendEvent(SYS_EVENT,0xca1bdead);
            return 1;
        }
    }
    else
    {
        // rf calibration has a old version
        hal_HstSendEvent(SYS_EVENT,0xca1b01d0);
        return 0;
    }
}


PRIVATE UINT32 calib_GenerateRfCrc(CONST VOID *data, UINT16 len)
{
    HAL_DMA_FCS_CFG_T   fcsCtx;
    CALIB_RF_CRC_T      fcs;

    fcs                 = 0;
    fcsCtx.srcAddr      = (CONST UINT8 *)data;
    fcsCtx.transferSize = len;
    fcsCtx.userHandler  = NULL;

    if (hal_DmaFcsStart(&fcsCtx) == HAL_ERR_NO)
    {
        hal_DmaReadFcs((UINT8*)&fcs);
    }
    else
    {
        sxr_ComputeFcs(fcsCtx.transferSize, fcsCtx.srcAddr, (UINT8*)&fcs);
    }

    return fcs;
}


PRIVATE CALIB_PARAM_STATUS_T calib_InitRfBuffer(VOID)
{

#if 0

    CALIB_PARAM_STATUS_T paramStatus = CALIB_PARAM_DEFAULT;
    UINT32  tag = g_calibCalibSector->versionTag;
    UINT32  mark = CALIB_MARK_MASK(tag);
    UINT8   majVer = CALIB_MAJ_MASK(tag);
#if (CALIB_CHECK_MINOR_VERSION)
    UINT8   minVer = CALIB_MIN_MASK(tag);
#endif

    //  Default calibration values from the RF drivers. 
    CONST CALIB_XCV_T *xcvDefaults = rfd_XcvCalibGetDefault();
    CONST CALIB_PA_T  *paDefaults =  rfd_PaCalibGetDefault();
    CONST CALIB_SW_T  *swDefaults =  rfd_SwCalibGetDefault();

    //  Check if the platform has been calibrated. 
    if ((mark == CALIB_MARK_VERSION) &&
        (majVer == CALIB_MAJ_VERSION) &&
#if (CALIB_CHECK_MINOR_VERSION)
        (minVer <= CALIB_MIN_VERSION) &&
#endif
        TRUE
       )
    {
#if (CALIB_CHECK_RF_NAME)
        // Check the RF chip names. If they are the same as the default
        // ones, don't use the flash structure.
        if (g_calibCalibSector->xcv.palcust.name == xcvDefaults->palcust.name &&
            g_calibCalibSector->pa.palcust.name ==  paDefaults->palcust.name &&
            g_calibCalibSector->sw.palcust.name ==  swDefaults->palcust.name)
        {
            paramStatus = CALIB_PARAM_RF_CALIBRATED;
        }
        else
        {
            //  Calibration parameters are present but RF chipset mismatch. 
            paramStatus = CALIB_PARAM_DEFAULT_RF_MIS;
        }
#else
        paramStatus = CALIB_PARAM_RF_CALIBRATED;
#endif
    }

    //  The platform has been calibrated, get parameters from flash. 
    if (CALIB_PARAM_RF_CALIBRATED == paramStatus)
    {
        // Copy calib param from flash to HST RAM buffer to be able to
        // modify them from HST. 
        calib_memcpy(&g_calibHstOpInfo,
                     &g_calibCalibSector->opInfo,
                     sizeof(g_calibHstOpInfo));

        calib_memcpy(&g_calibHstXcv,
                     &g_calibCalibSector->xcv,
                     sizeof(g_calibHstXcv));

        calib_memcpy(&g_calibHstPa,
                     &g_calibCalibSector->pa,
                     sizeof(g_calibHstPa));

        calib_memcpy(&g_calibHstSw,
                     &g_calibCalibSector->sw,
                     sizeof(g_calibHstSw));

        calib_memcpy(&g_calibHstBb.times,
                     &g_calibCalibSector->bb.times,
                     sizeof(g_calibHstBb.times));

        calib_memcpy(&g_calibHstBb.gpadc,
                     &g_calibCalibSector->bb.gpadc,
                     sizeof(g_calibHstBb.gpadc));

        // GPADC structure is changed after V2.4
        if (tag == 0xCA1B0204)
        {
            calib_ConvertStructV2p4((CALIB_BB_T*)&g_calibHstBb);
        }

        // Check CRC for RF calibration data
        calib_CheckRfCrc();
    }
    //  The platform hasn't been calibrated, we get default values from
    // the different RF chip modules (transceiver, PA and switch). 
    else
    {
        calib_SetRfBufferToDefault();
    }


    return paramStatus;
    #endif
    
}


PRIVATE CALIB_PARAM_STATUS_T calib_InitAudioBuffer(VOID)
{
    CALIB_PARAM_STATUS_T paramStatus = CALIB_PARAM_DEFAULT;
    UINT32  tag = g_calibCalibSector->versionTag;
    UINT32  mark = CALIB_MARK_MASK(tag);
    UINT32  audioTag = g_calibCalibSector->audioVersionTag;
    UINT32  audioMark = CALIB_MARK_MASK(audioTag);
    UINT8   audioMajVer = CALIB_MAJ_MASK(audioTag);
#if (CALIB_CHECK_MINOR_VERSION)
    UINT8   audioMinVer = CALIB_MIN_MASK(audioTag);
#endif

#if (AUDIO_CALIB_VER == 1)
    UINT32 audioExpandTag = g_calibCalibSector->audioExpand1VersionTag;
#endif

    if ((audioMark == CALIB_MARK_VERSION) &&
        (audioMajVer == CALIB_MAJ_VERSION) &&
#if (CALIB_CHECK_MINOR_VERSION)
        (audioMinVer <= CALIB_MIN_VERSION) &&
#endif
        TRUE
       )
    {
        paramStatus = CALIB_PARAM_AUDIO_CALIBRATED;
    }
    else if ((mark == CALIB_MARK_VERSION) &&
             (tag < 0xCA1B0205)
            )
    {
        // Consider audio data as calibrated even if RF names are mismatched
        paramStatus = CALIB_PARAM_AUDIO_CALIBRATED;
    }

#if (AUDIO_CALIB_VER == 1)
    // FIXME: currently audioExpandTag meaning is not defined
    if (audioExpandTag == CALIB_VERSION_NUMBER)
        paramStatus = CALIB_PARAM_AUDIO_CALIBRATED;
    else
        paramStatus = CALIB_PARAM_DEFAULT;
#endif
    if (CALIB_PARAM_AUDIO_CALIBRATED == paramStatus)
    {
        // Copy audio calib param from flash to HST RAM buffer to be able to
        // modify them from HST.
        calib_memcpy(&g_calibHstBb.audio,
                     &g_calibCalibSector->bb.audio,
                     sizeof(g_calibHstBb.audio));

        calib_memcpy(&g_calibHstIIR,
             &g_calibCalibSector->iirParam,
             sizeof(g_calibHstIIR));

        #if (AUDIO_CALIB_VER == 1)
        calib_memcpy(&g_calibHst_audio_voc,
             &g_calibCalibSector->audio_voc,
             sizeof(CALIB_AUD_VOC_T));
        calib_memcpy(&g_calibHst_audio_music,
             &g_calibCalibSector->audio_music,
             sizeof(CALIB_AUD_MUSIC_T));
         #endif
        // Out gain structure is changed in V2.3
        if (tag == 0xCA1B0202)
        {
            //calib_ConvertStructV2p2((CALIB_BB_T*)&g_calibHstBb);
        }
        // MIC gains during a sound recording is added in V2.6
        if (tag >= 0xCA1B0202 && tag < 0xCA1B0206)
        {
            //calib_ConvertStructV2p5((CALIB_BB_T*)&g_calibHstBb);
        }
    }
    else
    {
        calib_SetAudioBufferToDefault();
#ifndef DEFAULT_AUDIO_CALIB_PARAM_USED
        // The default audio calib data is calibrated by tool
        paramStatus = CALIB_PARAM_AUDIO_CALIBRATED;
#endif
    }

    return paramStatus;
}


//  -------------------------------------------------- 
//  ----- Calibration mechanism and structures init (USE CALIB). 

// At boot time, uses the the HST parameter Ram buffer 0 and
// copy the default parameters in it. 
PUBLIC VOID calib_DaemonInit(VOID)
{
    CALIB_PARAM_STATUS_T rfStatus, audioStatus;

    rfStatus = calib_InitRfBuffer();
    audioStatus = calib_InitAudioBuffer();

    g_calibCalibration.paramStatus = CALIB_PARAM_DEFAULT;
    if (CALIB_PARAM_RF_CALIBRATED == rfStatus)
    {
        if (CALIB_PARAM_AUDIO_CALIBRATED == audioStatus)
        {
            g_calibCalibration.paramStatus = CALIB_PARAM_CALIBRATED;
        }
        else
        {
            g_calibCalibration.paramStatus = CALIB_PARAM_RF_CALIBRATED;
        }
    }
    else if (CALIB_PARAM_DEFAULT_RF_MIS == rfStatus)
    {
        if (CALIB_PARAM_AUDIO_CALIBRATED == audioStatus)
        {
            g_calibCalibration.paramStatus = CALIB_PARAM_AUDIO_CALIBRATED_RF_MIS;
        }
        else
        {
            g_calibCalibration.paramStatus = CALIB_PARAM_DEFAULT_RF_MIS;
        }
    }
    else
    {
        if (CALIB_PARAM_AUDIO_CALIBRATED == audioStatus)
        {
            g_calibCalibration.paramStatus = CALIB_PARAM_AUDIO_CALIBRATED;
        }
        else
        {
            g_calibCalibration.paramStatus = CALIB_PARAM_DEFAULT;
        }
    }

    //  Set the global pointers to RAM buffers. 
    g_calibCalibration.opInfo =     &g_calibUsedOpInfo;
    g_calibCalibration.xcv =        &g_calibUsedXcv;
    g_calibCalibration.pa =         &g_calibUsedPa;
    g_calibCalibration.sw =         &g_calibUsedSw;
    g_calibCalibration.bb =         &g_calibUsedBb;
    g_calibCalibration.iirParam =   &g_calibUsedIIR;

    #if (AUDIO_CALIB_VER == 1)
    g_calibCalibration.audio_voc = &g_calibUsed_audio_voc; //0x00001CFC
    g_calibCalibration.audio_music= &g_calibUsed_audio_music; //0x00002A84
    #endif
    //  Set the global pointers used by HST to RAM buffers. 
    g_calibCalibration.hstOpInfo =     &g_calibHstOpInfo;
    g_calibCalibration.hstXcv =        &g_calibHstXcv;
    g_calibCalibration.hstPa =         &g_calibHstPa;
    g_calibCalibration.hstSw =         &g_calibHstSw;
    g_calibCalibration.hstBb =         &g_calibHstBb;
    g_calibCalibration.hstIIRParam =   &g_calibHstIIR;

    #if (AUDIO_CALIB_VER == 1)
    g_calibCalibration.hstaudio_voc = &g_calibHst_audio_voc; //0x00001CFC
    g_calibCalibration.hstaudio_music= &g_calibHst_audio_music; //0x00002A84
    #endif

    // Copy the calib param from HST buffers to HST buffers to
    // let HST read and modify them. 
    calib_UpdateBuffer();
}



// =============================================================================
// calib_DaemonSetContext
// -----------------------------------------------------------------------------
/// Defines the context structure that HST and JCES must use.
/// @param ctx Pointer to the context to use.
// =============================================================================
PUBLIC VOID calib_DaemonSetContext(VOID* ctx)
{
    g_calibCalibration.stubCtx = ctx;
}
PUBLIC VOID calib_DaemonSetNsftContext(VOID* ctx)
{
    g_calibCalibration.stubNsftCtx = ctx;
}
//  -------------------------------------------------- 
//  ----- Calibration command execution. 
PRIVATE VOID calib_PrepareRfData(CALIB_BUFFER_T *buffer)
{
    CALIB_VERSION_TAG_T tagConfigured = CALIB_VERSION_NUMBER;

    //  Write the RF calib data. 
    calib_memcpy(&buffer->opInfo,
                 g_calibCalibration.opInfo,
                 sizeof(buffer->opInfo));

    calib_memcpy(&buffer->xcv,
                 g_calibCalibration.xcv,
                 sizeof(buffer->xcv));

    calib_memcpy(&buffer->pa,
                 g_calibCalibration.pa,
                 sizeof(buffer->pa));

    calib_memcpy(&buffer->sw,
                 g_calibCalibration.sw,
                 sizeof(buffer->sw));

    calib_memcpy(&buffer->bb.times,
                 &g_calibCalibration.bb->times,
                 sizeof(buffer->bb.times));

    calib_memcpy(&buffer->bb.gpadc,
                 &g_calibCalibration.bb->gpadc,
                 sizeof(buffer->bb.gpadc));

    //  Write the tag saying that the Platform has been calibrated. 
    calib_memcpy(&buffer->versionTag,
                 &tagConfigured,
                 sizeof(buffer->versionTag));

    // Generate and write the CRC value for RF calibation data
    UINT32 rfCrc = calib_GenerateRfCrc(&buffer->versionTag,
                                     OFFSETOF(CALIB_BUFFER_T, bb) - OFFSETOF(CALIB_BUFFER_T, versionTag));
    calib_memcpy(&buffer->rfCrc,
                 &rfCrc,
                 sizeof(buffer->rfCrc));
}


PRIVATE VOID calib_PrepareAudioData(CALIB_BUFFER_T *buffer)
{
    CALIB_VERSION_TAG_T tagConfigured = CALIB_VERSION_NUMBER;

    // Write the audio calib data
    calib_memcpy(&buffer->bb.audio,
                 &g_calibCalibration.bb->audio,
                 sizeof(buffer->bb.audio));

    calib_memcpy(&buffer->iirParam,
                 g_calibCalibration.iirParam,
                 sizeof(buffer->iirParam));

#if (AUDIO_CALIB_VER == 1)
    calib_memcpy(&buffer->audio_voc,
                 g_calibCalibration.audio_voc,
                 sizeof(buffer->audio_voc));
    calib_memcpy(&buffer->audio_music,
                 g_calibCalibration.audio_music,
                 sizeof(buffer->audio_music));
        // FIXME: currently audioExpandTag meaning is not defined
    calib_memcpy(&buffer->audioExpand1VersionTag,
                 &tagConfigured,
                 sizeof(buffer->audioExpand1VersionTag));
#endif

    //  Write the tag saying that the audio data has been calibrated. 
    calib_memcpy(&buffer->audioVersionTag,
                 &tagConfigured,
                 sizeof(buffer->audioVersionTag));
}


/// Function used to program the flash calibration sector.
/// Hyp: MEMD Flash Driver opened before hand.
PRIVATE BOOL burn(CONST VOID* fshPptr, CONST VOID* srcPtr, UINT32 size)
{
    if (size == 0)
    {
        return TRUE;
    }

#ifdef CHIP_HAS_AP

    memcpy((UINT8*)HAL_SYS_GET_UNCACHED_ADDR(fshPptr), srcPtr, size);

#else // !CHIP_HAS_AP

    MEMD_ERR_T flashError;
    UINT32 len, addrFsh;

    //  Find the address local in the flash. 
    addrFsh = (UINT32)fshPptr - (UINT32)memd_FlashGetGlobalAddress(0);
    addrFsh &= 0x0fffffff;

    // Write calib flash sector. 
    // This function is in RAM, so it can be executed no matter
    // which sector is accessed to burn the calibration sector.
    // Moreover, this code is executed during the Fint interrupt,
    // which has a very high priority, so no other code (That could
    // come from the same bank) is executed.
    flashError = memd_FlashWrite((UINT8*)addrFsh, size, &len, (CONST UINT8*)srcPtr);

    //  Check flash writting. 
    if ((flashError != MEMD_ERR_NO) || (len != size))
    {
        //  Here we are screwed-up. Just return false. 
        calib_PrintVal(flashError);
        return FALSE;
    }

#endif // !CHIP_HAS_AP

    return TRUE;
}


PRIVATE BOOL calib_BurnBuffer(CONST VOID *buffer)
{
    CONST CALIB_BUFFER_T *calibBuffer = buffer;
    BOOL ok = TRUE;

    ok &= burn(&g_calibCalibSector->opInfo,
               &calibBuffer->opInfo,
               ((UINT32)&g_calibCalibSector->audioVersionTag -
                    (UINT32)&g_calibCalibSector->opInfo));
    ok &= burn(&g_calibCalibSector->iirParam,
               &calibBuffer->iirParam,
               sizeof(g_calibCalibSector->iirParam));

    #if (AUDIO_CALIB_VER == 1)
    // FIXME: currently audioExpandTag meaning is not defined
    ok &= burn(&g_calibCalibSector->audioExpand1VersionTag,
               &calibBuffer->audioExpand1VersionTag,
               sizeof(g_calibCalibSector->audioExpand1VersionTag));
    ok &= burn(&g_calibCalibSector->audio_voc,
               &calibBuffer->audio_voc,
               sizeof(g_calibCalibSector->audio_voc));
    ok &= burn(&g_calibCalibSector->audio_music,
               &calibBuffer->audio_music,
               sizeof(g_calibCalibSector->audio_music));
    #endif

    if (ok)
    {
        ok &= burn(&g_calibCalibSector->versionTag,
                   &calibBuffer->versionTag,
                   sizeof(g_calibCalibSector->versionTag));
    }

    if (ok)
    {
        ok &= burn(&g_calibCalibSector->rfCrc,
                   &calibBuffer->rfCrc,
                   sizeof(g_calibCalibSector->rfCrc));
    }

    if (ok)
    {
        ok &= burn(&g_calibCalibSector->audioVersionTag,
                   &calibBuffer->audioVersionTag,
                   sizeof(g_calibCalibSector->audioVersionTag));
    }

    return ok;
}


PRIVATE BOOL calib_BurnCurUsedData(VOID)
{
    CALIB_VERSION_TAG_T tagConfigured = CALIB_VERSION_NUMBER;
    BOOL ok = TRUE;

    //  Write the RF calib data. 
    ok &= burn(&g_calibCalibSector->opInfo,
               g_calibCalibration.opInfo,
               sizeof(g_calibCalibSector->opInfo));

    ok &= burn(&g_calibCalibSector->xcv,
               g_calibCalibration.xcv,
               sizeof(g_calibCalibSector->xcv));

    ok &= burn(&g_calibCalibSector->pa,
               g_calibCalibration.pa,
               sizeof(g_calibCalibSector->pa));

    ok &= burn(&g_calibCalibSector->sw,
               g_calibCalibration.sw,
               sizeof(g_calibCalibSector->sw));

    ok &= burn(&g_calibCalibSector->bb,
               g_calibCalibration.bb,
               sizeof(g_calibCalibSector->bb));

    if (ok)
    {
        //  Write the tag saying that the Platform has been calibrated. 
        ok &= burn(&g_calibCalibSector->versionTag,
                   &tagConfigured,
                   sizeof(g_calibCalibSector->versionTag));
    }

    if (ok)
    {
        // Generate and write the CRC value for RF calibation data
        UINT32 rfCrc = calib_GenerateRfCrc(&g_calibCalibSector->versionTag,
                                           OFFSETOF(CALIB_BUFFER_T, bb));
        ok &= burn(&g_calibCalibSector->rfCrc,
                   &rfCrc,
                   sizeof(g_calibCalibSector->rfCrc));
    }

    if (ok)
    {
        //  Write the tag saying that the audio data has been calibrated. 
        ok &= burn(&g_calibCalibSector->audioVersionTag,
                   &tagConfigured,
                   sizeof(g_calibCalibSector->audioVersionTag));
    }

    return ok;
}
#if (AUDIO_CALIB_VER == 1)
PRIVATE BOOL calib_BurnCurUsedAudioData(CALIB_VERSION_TAG_T tag)
{
    CALIB_VERSION_TAG_T tagConfigured = CALIB_VERSION_NUMBER;
    BOOL ok = TRUE;

    //  Write the RF calib data. 
    ok &= burn(&g_calibCalibSector->opInfo,
               g_calibCalibration.opInfo,
               sizeof(g_calibCalibSector->opInfo));

    ok &= burn(&g_calibCalibSector->xcv,
               g_calibCalibration.xcv,
               sizeof(g_calibCalibSector->xcv));

    ok &= burn(&g_calibCalibSector->pa,
               g_calibCalibration.pa,
               sizeof(g_calibCalibSector->pa));

    ok &= burn(&g_calibCalibSector->sw,
               g_calibCalibration.sw,
               sizeof(g_calibCalibSector->sw));

    calib_Print1("write to calibCalibSector bb: 0x%x", &g_calibCalibSector->bb);
    ok &= burn(&g_calibCalibSector->bb,
               g_calibCalibration.bb,
               sizeof(g_calibCalibSector->bb));

    ok &= burn(&g_calibCalibSector->iirParam,
               g_calibCalibration.iirParam,
               sizeof(g_calibCalibSector->iirParam));

    calib_Print1("write to calibCalibSector audio_voc: 0x%x", &g_calibCalibSector->audio_voc);
    calib_Print1("write to calibCalibSector audio_music: 0x%x", &g_calibCalibSector->audio_music);
    // FIXME: currently audioExpandTag meaning is not defined
    ok &= burn(&g_calibCalibSector->audioExpand1VersionTag,
               &tagConfigured,
               sizeof(g_calibCalibSector->audioExpand1VersionTag));
    ok &= burn(&g_calibCalibSector->audio_voc,
               g_calibCalibration.audio_voc,
               sizeof(g_calibCalibSector->audio_voc));
    ok &= burn(&g_calibCalibSector->audio_music,
               g_calibCalibration.audio_music,
               sizeof(g_calibCalibSector->audio_music));

    if (ok)
    {
        //  Write the tag saying that the Platform has been calibrated. 
        ok &= burn(&g_calibCalibSector->versionTag,
                   &tag,
                   sizeof(g_calibCalibSector->versionTag));
    }

    if (ok)
    {
        // Generate and write the CRC value for RF calibation data
        UINT32 rfCrc = calib_GenerateRfCrc(&g_calibCalibSector->versionTag,
                                           OFFSETOF(CALIB_BUFFER_T, bb) - OFFSETOF(CALIB_BUFFER_T, versionTag));
        ok &= burn(&g_calibCalibSector->rfCrc,
                   &rfCrc,
                   sizeof(g_calibCalibSector->rfCrc));
    }

    if (ok)
    {
        //  Write the tag saying that the audio data has been calibrated. 
        calib_Print1("write to calibCalibSector audioVersionTag: 0x%x", &g_calibCalibSector->audioVersionTag);
        ok &= burn(&g_calibCalibSector->audioVersionTag,
                   &tagConfigured,
                   sizeof(g_calibCalibSector->audioVersionTag));
    }

    return ok;
}

PUBLIC BOOL calib_BurnFlash(VOID)
{
    UINT32 calibSectorStart;
    UINT32 calibSectorEnd;
    CALIB_VERSION_TAG_T tag = g_calibCalibSector->versionTag;

#ifdef CHIP_HAS_AP

    calibSectorStart = HAL_SYS_GET_UNCACHED_ADDR(g_calibCalibSector);
    calibSectorEnd = HAL_SYS_GET_UNCACHED_ADDR(&_factory_start);
    memset((UINT8*)calibSectorStart, 0xFF, calibSectorEnd-calibSectorStart);

#else // !CHIP_HAS_AP

    // The dst_ptr is a local flash address, this is UINT32. 
    MEMD_ERR_T flashError;

    // Erase calib flash sector.
    calibSectorStart = HAL_SYS_GET_UNCACHED_ADDR(g_calibCalibSector) -
                HAL_SYS_GET_UNCACHED_ADDR(memd_FlashGetGlobalAddress(0));

    calibSectorEnd = HAL_SYS_GET_UNCACHED_ADDR(&_factory_start) -
                HAL_SYS_GET_UNCACHED_ADDR(memd_FlashGetGlobalAddress(0));

    hal_SysEnterCriticalSection();
    flashError = memd_FlashErase((UINT8*)calibSectorStart, (UINT8*)calibSectorEnd);

    if (flashError != MEMD_ERR_NO)
    {
        // In case of error, just say it to HST. 
        calib_Print("ERROR! Calib flash sector erase problem!");
        calib_PrintVal(flashError);
        return FALSE;
    }
    Flash_CalibWriteFlashFlag(TRUE);
#endif
    if (!calib_BurnCurUsedAudioData(tag))
    {
        // TODO: we should say it to HST in case of error
        calib_Print("ERROR! Calib flash sector burn problem!");
    #ifndef CHIP_HAS_AP
        Flash_CalibWriteFlashFlag(FALSE);
    #endif
        return FALSE;
    }

#ifdef CHIP_HAS_AP
    hal_ApCommSetFactoryUpdateCmd(HAL_AP_COMM_FACT_UPDATE_CALIB);
#else
    Flash_CalibWriteFlashFlag(FALSE);
#endif

    return TRUE;
}

PUBLIC VOID calib_UpdateBufferData(CALIB_BUFFER_T *buffer)
{
    calib_memcpy(g_calibCalibration.audio_voc,
                 &buffer->audio_voc,
                 sizeof(CALIB_AUD_VOC_T));
    calib_memcpy(g_calibCalibration.audio_music,
                 &buffer->audio_music,
                 sizeof(CALIB_AUD_MUSIC_T));
    calib_memcpy(&g_calibCalibration.bb->audio,
                 &buffer->bb.audio,
                 sizeof(buffer->bb.audio));
    calib_memcpy(g_calibCalibration.iirParam,
                 &buffer->iirParam,
                 sizeof(CALIB_AUDIO_IIR_PARAM_T));
}

#endif


//  Function used to update the Platform's used calibration buffers when the
//  user modifies them with HST. It also executes calib cmd. 
PUBLIC VOID calib_DaemonProcess(VOID)
{
    // Check out if some calibration update has to be done.   
    CALIB_COMMAND_T tag = *((CALIB_COMMAND_T *)HAL_SYS_GET_UNCACHED_ADDR(
                                        (UINT32)(&g_calibCalibration.command)));
    CALIB_BUFFER_T *burnBuffer = NULL;

    // An error is pending or there is no command to execute. 
    if (CALIB_CMD_NOT_ACCESSIBLE == tag || CALIB_CMD_DONE == tag ||
        CALIB_CMD_FLASH_ERROR == tag)
    {
        goto _exit;
    }

    // Debug print. 
    calib_Print("A calib command has been found. Executing...");

    #ifdef CALIB_AUDIO_OTHER

    // --- Calibration parameters must be updated. --- 
    if (CALIB_CMD_UPDATE == tag)
    {
        //  Copy the calib param from HST buffers to HST buffers to
        //  let HST read and modify them. 
        calib_UpdateBuffer();

        // Update RFD calibrations
        rfd_XcvCalibUpdateValues();
        rfd_SwCalibUpdateValues();
        rfd_PaCalibUpdateValues();

        calib_Print("Calibration parameters updated.");
    }

    // --- Calibration parameters must be reset to default values. --- 
    if (CALIB_CMD_RF_RESET == tag ||
        CALIB_CMD_RESET == tag)
    {
        // Set the HST calib buffers to the default values. 
        calib_SetRfBufferToDefault();

        // Copy the calib param from HST buffers to used buffers. 
        calib_UpdateRfBuffer();

        // Call each module to ask him to reset its calib param,
        // if needed (i.e. for custom parameters like CDAC, HAL_A, etc.). 
        rfd_XcvCalibResetValues();
        rfd_PaCalibResetValues();
        rfd_SwCalibResetValues();

        calib_Print("RF calib parameters reset.");
    }
    #endif

    if (CALIB_CMD_AUDIO_RESET == tag ||
        CALIB_CMD_RESET == tag)
    {
        // Set the HST calib buffers to the default values. 
        calib_SetAudioBufferToDefault();

        // Copy the calib param from HST buffers to used buffers. 
        calib_UpdateAudioBuffer();

        calib_Print("Audio calib parameters reset.");
    }

    // --- The flash must be erased! --- 
    if (CALIB_CMD_FLASH_ERASE == tag ||
        CALIB_CMD_RF_FLASH_BURN == tag ||
        CALIB_CMD_AUDIO_FLASH_BURN == tag ||
        CALIB_CMD_FLASH_BURN == tag)
    {
        UINT32 calibSectorStart;
        UINT32 calibSectorEnd;

        if (CALIB_CMD_RF_FLASH_BURN == tag ||
            CALIB_CMD_AUDIO_FLASH_BURN == tag)
        {
            burnBuffer = (CALIB_BUFFER_T*)sxr_Malloc(sizeof(*g_calibCalibSector));
            memcpy(burnBuffer, g_calibCalibSector, sizeof(*g_calibCalibSector));
        }

#ifdef CHIP_HAS_AP

        if (CALIB_CMD_FLASH_ERASE == tag)
        {
            calibSectorStart = HAL_SYS_GET_UNCACHED_ADDR(g_calibCalibSector);
            calibSectorEnd = HAL_SYS_GET_UNCACHED_ADDR(&_factory_start);
            memset((UINT8*)calibSectorStart, 0xFF, calibSectorEnd-calibSectorStart);
        }

#else // !CHIP_HAS_AP

        //  The dst_ptr is a local flash address, this is UINT32. 
        MEMD_ERR_T flashError;

        //  Erase calib flash sector.
        calibSectorStart = HAL_SYS_GET_UNCACHED_ADDR(g_calibCalibSector) -
                    HAL_SYS_GET_UNCACHED_ADDR(memd_FlashGetGlobalAddress(0));

        calibSectorEnd = HAL_SYS_GET_UNCACHED_ADDR(&_factory_start) -
                    HAL_SYS_GET_UNCACHED_ADDR(memd_FlashGetGlobalAddress(0));

        // This function is in RAM, so it can be executed no matter
        // which sector is accessed to burn the calibration sector.
        // Moreover, this code is executed during the Fint interrupt,
        // which has a very high priority, so no other code (That could
        // come from the same bank) is executed.
        if ((flashError = memd_FlashErase((UINT8*)calibSectorStart,
                            (UINT8*)calibSectorEnd)) != MEMD_ERR_NO)
        {
            // In case of error, just say it to HST. 
            calib_Print("ERROR! Calib flash sector erase problem!");
            calib_PrintVal(flashError);
            g_calibCalibration.command = CALIB_CMD_FLASH_ERROR;
            goto _exit;
        }

#endif // !CHIP_HAS_AP

        // Say that the flash has been erased. 
        calib_Print("The calib flash sector has been erased successfully!");
    }

    //  --- The flash must be burnt! --- 
    if (CALIB_CMD_RF_FLASH_BURN == tag ||
        CALIB_CMD_AUDIO_FLASH_BURN == tag)
    {
    #ifdef CALIB_AUDIO_OTHER
        if (CALIB_CMD_RF_FLASH_BURN == tag)
        {
            calib_Print("Prepare RF calib data.");
            calib_PrepareRfData(burnBuffer);
        }
    #endif

        if (CALIB_CMD_AUDIO_FLASH_BURN == tag ||
#ifndef DEFAULT_AUDIO_CALIB_PARAM_USED
            // The default audio calib data is calibrated by tool
            CALIB_CMD_RF_FLASH_BURN == tag ||
#endif
            FALSE
           )
        {
            calib_Print("Prepare audio calib data.");
            calib_PrepareAudioData(burnBuffer);
        }

        //  The calib sector in flash has already been erased. 
        if (!calib_BurnBuffer(burnBuffer))
        {
            // In case of error, just say it to HST. 
            calib_Print("ERROR! Calib flash sector burn problem!");
            g_calibCalibration.command = CALIB_CMD_FLASH_ERROR;
            goto _exit;
        }

        calib_Print("The calib flash sector has been burnt successfully!");
    }

    if (CALIB_CMD_FLASH_BURN == tag)
    {
        if (!calib_BurnCurUsedData())
        {
            // In case of error, just say it to HST. 
            calib_Print("ERROR! Calib flash sector burn problem!");
            g_calibCalibration.command = CALIB_CMD_FLASH_ERROR;
            goto _exit;
        }

        calib_Print("The calib flash sector has been burnt successfully!");
    }

#ifdef CHIP_HAS_AP
    if (CALIB_CMD_FLASH_ERASE == tag ||
        CALIB_CMD_RF_FLASH_BURN == tag ||
        CALIB_CMD_AUDIO_FLASH_BURN == tag ||
        CALIB_CMD_FLASH_BURN == tag ||
        CALIB_CMD_CFP_BURN == tag)
    {
        if (pal_GetCalibProcess())
        {
            // In calib mode or autocall mode
            // Disable calib process
            pal_SetCalibProcess(FALSE);
            // Tell AP the calibration has been done
            syscmds_SendCalibDoneMsg();
            // Need to wait for the response from AP

            calib_Print("Notify AP to do flash operation!");
        }
        else
        {
            // In normal mode
            // Application is trying to update calibation data by calib_DaemonUsrDataProcess()
            hal_ApCommSetFactoryUpdateCmd(HAL_AP_COMM_FACT_UPDATE_CALIB);
            g_calibCalibration.command = CALIB_CMD_DONE;
        }
    }
    else
#endif
    {
        // --- Calibration is done --- 
        // Inform HST that the command has been processed
        g_calibCalibration.command = CALIB_CMD_DONE;
    }

_exit:
    if (burnBuffer)
    {
        sxr_Free(burnBuffer);
    }

    return;
}


// =============================================================================
// calib_DaemonUsrDataProcess
// -----------------------------------------------------------------------------
/// Apply and burn HST calibration buffer.
/// @return TRUE if success, and FALSE otherwise.
// =============================================================================
PUBLIC BOOL calib_DaemonUsrDataProcess(VOID)
{
    UINT32 scStatus;
    BOOL result;
    CALIB_COMMAND_T cmd = CALIB_CMD_FLASH_BURN;

    calib_UpdateBuffer();

    scStatus = hal_SysEnterCriticalSection();

#ifdef CHIP_HAS_AP
    if (!g_calibAutoCallMode)
#endif
    {
        pal_SetCalibProcess(FALSE);
    }

    g_calibCalibration.command = cmd;
    *((CALIB_COMMAND_T *)HAL_SYS_GET_UNCACHED_ADDR(
        (UINT32)(&g_calibCalibration.command))) = cmd;

    calib_DaemonProcess();

    hal_SysExitCriticalSection(scStatus);

#ifdef CHIP_HAS_AP
    if (g_calibAutoCallMode)
    {
        while (g_calibCalibration.command == cmd)
        {
            COS_Sleep(20);
        }
    }
#endif

    result = (g_calibCalibration.command == CALIB_CMD_DONE);

#ifdef CHIP_HAS_AP
    if (!g_calibAutoCallMode)
#endif
    {
        pal_SetCalibProcess(TRUE);
    }

    return result;
}


// =============================================================================
// calib_GetRfCalibStatus
// -----------------------------------------------------------------------------
/// Get the status of RF calibration data.
/// @return 0 if calibrated with good CRC, 1 if calibrated with bad CRC,
///         2 if not calibrated.
// =============================================================================
PUBLIC UINT8 calib_GetRfCalibStatus(VOID)
{
    if (g_calibCalibration.paramStatus == CALIB_PARAM_RF_CALIBRATED ||
        g_calibCalibration.paramStatus == CALIB_PARAM_CALIBRATED)
    {
        return calib_CheckRfCrc();
    }

    // RF not calibrated
    return 2;
}


// =============================================================================
// calib_GetAudioCalibStatus
// -----------------------------------------------------------------------------
/// Get the status of audio calibration data.
/// @return 0 if calibrated, 2 if not calibrated.
// =============================================================================
PUBLIC UINT8 calib_GetAudioCalibStatus(VOID)
{
    if (g_calibCalibration.paramStatus == CALIB_PARAM_AUDIO_CALIBRATED ||
        g_calibCalibration.paramStatus == CALIB_PARAM_CALIBRATED)
    {
        return 0;
    }

    // Audio not calibrated
    return 2;
}


#ifdef CHIP_HAS_AP
// =============================================================================
// calib_DaemonSetAutoCallMode
// -----------------------------------------------------------------------------
/// Tell calibration daemon process whether current mode is autocall.
// =============================================================================
PUBLIC VOID calib_DaemonSetAutoCallMode(BOOL autocall)
{
    g_calibAutoCallMode = autocall;
}


// =============================================================================
// calib_DaemonHandleApResponse
// -----------------------------------------------------------------------------
/// Receive the flash burning result from AP bootloader.
// =============================================================================
PUBLIC VOID calib_DaemonHandleApResponse(BOOL result)
{
    CALIB_COMMAND_T POSSIBLY_UNUSED tag =
        *((CALIB_COMMAND_T *)HAL_SYS_GET_UNCACHED_ADDR(
            (UINT32)(&g_calibCalibration.command)));
    //  --- Calibration is done --- 
    // Inform HST that the command has been processed
    if (result)
    {
        calib_Print1("AP has finished the flash operation successfully: 0x%08x", tag);
        g_calibCalibration.command = CALIB_CMD_DONE;
    }
    else
    {
        calib_Print1("ERROR! AP failed to do the flash operation: 0x%08x", tag);
        g_calibCalibration.command = CALIB_CMD_FLASH_ERROR;
    }

    // Re-enable calib process
    pal_SetCalibProcess(TRUE);
}
#endif


